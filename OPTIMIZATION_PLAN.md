# План оптимизации для обработки большого количества файлов (70k+)

## Проблема
При большом количестве файлов (70k+) программа тормозит в следующих местах:
1. **Чтение всех файлов в память** - `listDirByReadDir()` загружает все файлы сразу
2. **Линейный поиск в printed.txt** - `printedCheck()` читает файл построчно для каждого файла
3. **Сортировка по номеру ФД** - сортировка большого массива файлов

## План оптимизации

### 1. Индексирование printed.txt (Приоритет: ВЫСОКИЙ)
**Проблема**: Каждый файл проверяется в `printed.txt` построчно (O(n) для каждого файла)
**Решение**: 
- При старте загружать `printed.txt` в `map[string]bool`
- Заменить `printedCheck()` на `printedFiles[v]` (O(1) поиск)
- **Ожидаемый эффект**: 1000x ускорение при 70k файлах

### 2. Ленивая загрузка файлов (Приоритет: СРЕДНИЙ)
**Проблема**: Все файлы загружаются в память сразу
**Решение**:
- Читать файлы порциями (например, по 1000-5000)
```go
type FileProcessor struct {
    batchSize int
    currentBatch []string
    // ...
}
```
- Обрабатывать порцию → переходить к следующей
- **Ожидаемый эффект**: Снижение потребления памяти на 80-90%

### 3. Оптимизация сортировки (Приоритет: НИЗКИЙ)
**Проблема**: Сортировка всех файлов по номеру ФД
**Решение**:
- Сортировать только текущую порцию файлов
- Или использовать более эффективные алгоритмы сортировки
- **Ожидаемый эффект**: Незначительное ускорение

### 4. Batch-операции для printed.txt (Приоритет: СРЕДНИЙ)
**Проблема**: Запись в `printed.txt` происходит построчно
**Решение**:
- Накопить список напечатанных файлов в памяти
- Записывать в `printed.txt` батчами (например, каждые 100 файлов)
- **Ожидаемый эффект**: Ускорение записи, снижение I/O операций

## Реализация по этапам

### Этап 1: Индексирование printed.txt
```go
var printedFiles map[string]bool

func initPrintedFilesIndex() {
    printedFiles = make(map[string]bool)
    // Загрузить printed.txt в map
}

func isPrinted(filename string) bool {
    return printedFiles[filename]
}
```

### Этап 2: Ленивая загрузка
```go
func processFilesInBatches() {
    for {
        batch := getNextBatch()
        if len(batch) == 0 {
            break
        }
        processBatch(batch)
    }
}
```

### Этап 3: Batch-запись
```go
var printedBuffer []string

func markAsPrinted(filename string) {
    printedBuffer = append(printedBuffer, filename)
    if len(printedBuffer) >= 100 {
        flushPrintedBuffer()
    }
}
```

## Ожидаемые результаты
- **Этап 1**: 1000x ускорение проверки printed.txt
- **Этап 2**: Снижение потребления памяти на 80-90%
- **Этап 3**: Ускорение записи в 10-50 раз

## Ограничения
- **НЕ используем горутины** для проверки марок и печати (работа с оборудованием)
- **НЕ используем горутины** для последовательных операций
- Сохраняем строгую последовательность обработки файлов

## Тестирование
1. Создать тестовую директорию с 1000+ файлами
2. Измерить время обработки до и после оптимизации
3. Проверить корректность работы с printed.txt
4. Убедиться в отсутствии дублирования файлов

## Риски
- Увеличение потребления памяти для индекса printed.txt
- Сложность отладки при batch-обработке
- Возможные проблемы при прерывании программы (незаписанные данные)

## Альтернативы
- Использование SQLite для хранения информации о напечатанных файлах
- Индексирование файловой системы (например, через Windows Search)
- Использование специализированных библиотек для работы с большими директориями
